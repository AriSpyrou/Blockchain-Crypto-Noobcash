from flask import Flask, request
import json
import requests
from time import time_ns as time, sleep
import rsa
from nbc_lib import Block, Transaction
import socket
from threading import Timer
from Crypto.Hash import SHA256
import secrets

app = Flask(__name__)

def generate_wallet():
    # poolsize is related to the # of CPU threads available
    pubkey, privkey = rsa.newkeys(1024, poolsize=2)
    return f'{pubkey.n}:{pubkey.e}', privkey


def broadcast(endpoint, payload, attempts = 5):
    responses = []
    for node in nodes:
        if node['id'] == my_id['id']:
            continue
        retry_attempts = 0
        while retry_attempts < attempts:
            req = requests.post(f"http://{node['ip']}:{node['port']}/{endpoint}", json=json.dumps(payload))
            if req.ok:
                responses.append(req)
                break
            else:
                print(f"Failed to Broadcast to {endpoint} of Node {node['ip']}. Retrying...")
                sleep(2 ** retry_attempts)
                retry_attempts += 1
    return responses


def create_transaction(receiver_address, amount):
    pos = int(my_id['id'])
    unspent = utxo[pos]
    enough = False
    tmp = 0
    for i, un in enumerate(unspent):
        tmp += un['amount']
        if tmp >= amount:
            enough = True
            inputs = unspent[:i+1]
            diff = tmp - amount
            break
    if enough:
        trans = {'sender_address': pubkey, 'receiver_address': receiver_address, 'amount': amount, 'inputs': inputs}
        trans['id'] = hash_it([trans['sender_address'], trans['receiver_address'], trans['amount']])
        t_out1 = {'id': hash_it([time(), trans['id'], receiver_address, amount]), 'id': trans['id'], 'recipient': receiver_address, 'amount': amount}
        t_out2 = {'id': hash_it([time(), trans['id'], pubkey, diff]), 'id': trans['id'], 'recipient': pubkey, 'amount': diff}
        trans['outputs'] = [t_out1, t_out2]
        del unspent[:i+1]
        unspent.append(t_out2)
        pos = find_index_by(public_key=receiver_address)
        unspent = utxo[pos]
        unspent.append(t_out1)
        trans['signature'] = sign_transaction(trans, privkey)
        # Send the mofo to everyone in the bitconnetwork
        broadcast_transaction(trans)
        # Add the mofo to the queue
        trans_queue.append(trans)
        if len(trans_queue) >= C:
            new_block = mine_block()
            blockchain.append(new_block)
            broadcast_block(new_block)
    else:
        print('[ERROR]  Insufficient Funds in Wallet')


def sign_transaction(trans, privkey):
    # hash and sign message in one operation
    signature = rsa.sign(str([trans['sender_address'], trans['receiver_address'], trans['amount']]).encode("utf-8"), privkey, 'SHA-256').decode('ISO-8859-1')
    return signature


def broadcast_transaction(trans):
    broadcast("get-transaction", payload=trans)


def verify_signature(trans):
    """
    Verifies the signature matches the transaction. 
    This is executed by the receiver.

    inputs:
    trans - signed transaction
    pubkey - public key of the sender
    signature - signature generated by sign_transaction

    outputs:
    True if valid, False if invalid
    """
    try:
        sig = trans['signature'].encode('ISO-8859-1')
        n, e = trans['sender_address'].split(':')
        rsa.verify(str([trans['sender_address'], trans['receiver_address'], trans['amount']]).encode("utf-8"), sig, rsa.PublicKey(int(n), int(e)))
        print('[SUCCESS]    Signature Verified')
        return True
    except rsa.VerificationError:
        print('[SIGNATURE ERROR]    Signature Verification Failed')
        return False


def validate_transaction(trans):
    print('[INFO]    Transaction Received')
    # If signature checks out go ahead
    print('[INFO]    Checking Signature')
    if verify_signature(trans):
        # Look for the node that corresponds to the public key
        pos = find_index_by(public_key=trans['sender_address'])
        # Link the two lists
        unspent = utxo[pos]
        ok_flag = True
        tmp = []
        # List with all IDs from unspent
        unspent_ids = [item['id'] for item in unspent]
        # For every input we want to validate
        print('[INFO]    Ensuring Validity of Inputs')
        for i, inp in enumerate(trans['inputs']):
            input_id = inp['id']
            # Check to see if it is in unspent_ids
            if input_id not in unspent_ids:
                print('[ERROR]    Invalid Input Found!')
                # If even 1 is invalid then stop looping
                ok_flag = False
                break
            else:
                # If it is found then add it to a temp list
                tmp.append(unspent_ids.index(input_id))
        # If all inputs are found and everything is a-ok
        if ok_flag:
            print('[SUCCESS]    Inputs Validated')
            # Loop through the temp list we made earlier with the positions of UTXOs that need to be removed
            for i in tmp:
                del unspent[i]
            # Add the output of the transaction to the spender ie the change from the removed UTXOs
            unspent.append(trans['outputs'][1])
            # Find the receiver in nodes and
            pos = find_index_by(public_key=trans['receiver_address'])
            # Add the output of the transaction to the receiver ie the money transfered
            unspent = utxo[pos]
            unspent.append(trans['outputs'][0])
            return True
    return False


def wallet_balance(id):
    """
    Inputs: wallet id in 'idX' format or 
    """
    if isinstance(id, str):
        if 'id' in id:
            idx = find_index_by(id=id)
        else:
            idx = int(id)
    else:
        idx = id

    unspent = utxo[idx]
    return sum([item['amount'] for item in unspent])



def broadcast_block(block):
    broadcast("get-block", payload=block)


def mine_block():
    global trans_queue
    if len(trans_queue) >= C:
        #TODO fix blockchain so that new transactions are added
        transactions = [item for item in trans_queue[:C]]
        previous_block = blockchain[-1]
        new_idx = previous_block['index'] + 1
        # Possibly add PID and/or random sleep
        timestamp = time()
        previous_hash = previous_block['current_hash']
        print('[BLOCK]  Started Mining')
        while True:
            temp = {'index': new_idx, 'timestamp': timestamp, 'transactions': transactions, 'nonce': secrets.randbits(128),'previous_hash': previous_hash}
            temp['current_hash'] = hash_it([temp['timestamp'], temp['transactions'], temp['nonce']])
            if temp['current_hash'][:D] == D*'0':
                print('[BLOCK]  Suitable Hash Found!')
                trans_queue = trans_queue[C:]
                return temp


def validate_block(block, verbose=True):
    cor_previous_hash = blockchain[-1]['current_hash']
    
    if block['previous_hash'] == cor_previous_hash:
        if verbose: print(f"[BLOCK] Previous Hash Validated for Block {block['index']}")
        curr_block_hash = hash_it([block['timestamp'], block['transactions'], block['nonce']])
        if block['current_hash'] == curr_block_hash:
            if verbose: print(f"[BLOCK] Current Hash Validated for Block {block['index']}")
            return True
        return False
    else:
        resolve_conflict()

def validate_chain():
    chain = blockchain[1:]
    for block in chain:
        if not validate_block(block, verbose=False):
            print("[BLOCKCHAIN] Chain Validation Failed")
            resolve_conflict()


def resolve_conflict():
    global blockchain
    responses = []
    for node in nodes:
        if node['id'] == my_id['id']:
            continue
        retry_attempts = 0
        while retry_attempts < 5:
            req = requests.get(f"http://{node['ip']}:{node['port']}/get-chain")
            if req.ok:
                lst = [json.loads(item) for item in req.json()]
                responses.append(lst)
                break
            else:
                print(f"[INFO]  Failed to Broadcast to 'get-chain' of Node {node['ip']}. Retrying...")
                sleep(2 ** retry_attempts)
                retry_attempts += 1
    # find the maximal blockchain and keep it
    max_chain = max(responses, key=len)
    blockchain = max_chain



def send_nodes_to_all(nodes):
    while True:
        if len(nodes) == N:
            for node in nodes[1:]:
                print(f"[INFO]  Sent Node List to {node['id']}")
                requests.post(f"http://{node['ip']}:{node['port']}/get-nodes", json=json.dumps(nodes))
                requests.post(f"http://{node['ip']}:{node['port']}/get-blockchain", json=json.dumps(blockchain))
            break
        else:
            sleep(5)
    for node in nodes[1:]:
        create_transaction(node['pubkey'], 100)


def find_index_by(id=None, public_key=None):
    """
    Finds a node in nodelist 

    Input: id in 'idX' format or public key

    Returns: an index in nodelist
    """
    if id:
        if 'id' in id:
            num = id[2:]
            for i, node in enumerate(nodes):
                if node['id'] == num:
                    return i
        if isinstance(id, int):
            return id-1
    elif public_key:
        for node in nodes:
            if public_key == node['pubkey']:
                return int(node['id'])


def read_transactions(filename):
    with open(filename) as file:
        transactions = file.readlines()
        
    for tr in transactions:
        create_transaction(find_index_by(tr.split()[0]), tr.split()[1])


def hash_it(*args):
    hsh = SHA256.new()
    for a in args:
        hsh.update(bytes(str(a), 'utf-8'))
    return hsh.hexdigest()

@app.route("/join-network", methods=['POST'])
def join_network():
    if request.method == 'POST':
        rec = json.loads(request.json)
        ip = rec['ip']
        port = rec['port']
        pubkey = rec['pubkey']
        print(f'[INFO]  Connection from: {ip}:{port}')
        c_id = str(len(nodes))
        nodes.append({'id': c_id, 'ip': ip, 'port': port, 'pubkey': pubkey})
        print(f'[SUCCESS]   Added Node: {c_id}: {ip}:{port} to Network')

        return json.dumps({'cni': f'{c_id}'})


@app.route("/get-<lst>", methods=['POST'])
def get_nodes(lst):
    global nodes, blockchain
    if request.method == 'POST':
        if lst == 'nodes':
            nodes = json.loads(request.json)
            return 'OK'
        elif lst == 'blockchain':
            blockchain = json.loads(request.json)
            unspent = utxo[0]
            if len(blockchain[0]['transactions']) == 1:
                trans = blockchain[0]['transactions'][0]
            unspent.append(trans['outputs'][0])
            return 'OK'


@app.route("/get-transaction", methods=['POST'])
def get_transaction():
    if request.method == 'POST': 
        trans = json.loads(request.json)
        if validate_transaction(trans):
            print("[SUCCESS]    Transaction Validation Successful")
            trans_queue.append(trans)
            if len(trans_queue) >= C:
                new_block = mine_block()
                blockchain.append(new_block)
                broadcast_block(new_block)
        else:
            print("[ERROR]  Transaction Validation Failed")
    return 'OK'


@app.route("/get-block", methods=['POST'])
def get_block():
    if request.method == 'POST':
        block = json.loads(request.json)
        if validate_block(block):
            blockchain.append(block)
        else:
            print("[ERROR] Block Validation Failed")
        return 'OK'


@app.route("/get-chain", methods=['GET'])
def get_chain():
    if request.method == 'GET':
        return json.dumps([json.dumps(block) for block in blockchain])

@app.route("/get-balance", methods=['GET'])
def get_balance():
    if request.method == 'GET':
        pass # TODO

@app.route("/new-transaction", methods=['POST'])
def new_transaction():
    if request.method == 'POST':
        post_data = request.get_json()
        receiver_address = post_data.get('receiver_address')
        amount = post_data.get('amount')
        tmp = nodes[find_index_by(id=receiver_address)]
        create_transaction(tmp['pubkey'], int(amount))
        return 'OK'

# Finding our local IP address by pinging the 0th node/gateway on port 80
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.connect(("192.168.0.1", 80))
my_ip = s.getsockname()[0]
my_port = 5000

# Hyperparameters
if my_ip == "192.168.0.1":  
    BOOTSTRAP = 1  # hyperparameter to determine the bootstrap node
else:
    BOOTSTRAP = 0
N = 3  # hyperparameter / number of total nodes connected to nbc network
C = 2 # hyperparameter / capacity
D = 3 # hyperparameter / difficulty

# Generating RSA key pair
pubkey, privkey = generate_wallet()
# Check if there is a node running on port 5000
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    if s.connect_ex((my_ip, 5000)) == 0:
        my_port = 5001

my_id = {'id': '0', 'ip': my_ip, 'port': my_port, 'pubkey': pubkey}

utxo = [[] for _ in range(N)]
nodes = []
trans_queue = []
blockchain = []

# Create genesis block and genesis transaction, only for node 0
if BOOTSTRAP:
    # Add bootstrap's id to nodes
    nodes = [my_id]
    # Create the genesis transaction
    genesis_transaction = {'sender_address':0, 'receiver_address':pubkey, 'amount':100 * N, 'inputs':None, 'outputs':[], 'signature':None}
    genesis_transaction['id'] = hash_it([genesis_transaction['sender_address'], genesis_transaction['receiver_address'], genesis_transaction['amount']])

    # This is for code compatibility and so that the next line isn't super long
    trans = genesis_transaction
    # Add the single output of the genesis transaction to it
    genesis_transaction['outputs'] = [{'id': hash_it([time(), trans['id'], pubkey, 100 * N]), 'id': trans['id'], 'recipient': pubkey, 'amount': 100 * N}]
    utxo[0].append(genesis_transaction['outputs'][0])
    # Create the genesis block
    genesis_block = {'index':0, 'timestamp':time(), 'transactions':[genesis_transaction], 'nonce':0, 'previous_hash':-1}
    genesis_block['current_hash'] = hash_it([genesis_block['timestamp'], genesis_block['transactions'], genesis_block['nonce']])
    blockchain.append(genesis_block)

if __name__ == '__main__':
    if not BOOTSTRAP:
        # Node makes join request and joins the network
        # If it fails it retries in 5 seconds until the 
        # bootstrap server is up and running
        while True:
            try:
                x = requests.post('http://192.168.0.1:5000/join-network', json=json.dumps(my_id)).json()
                my_id['id'] = x['cni']
                break
            except requests.exceptions.ConnectionError:
                print('Server unreachable retrying in 5s...')
                sleep(5)
                continue
    else:
        # The bootstrap server starts a thread which waits for all nodes to 
        # connect and then sends each server's credentials to all of them
        Timer(1, send_nodes_to_all, [nodes]).start()
    app.run(host=my_ip, port=my_id['port'], debug=False)
